package com.mrburgerus.betaplus.world.biome;

import biomesoplenty.api.biome.BOPBiomes;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.mrburgerus.betaplus.BetaPlus;
import com.mrburgerus.betaplus.util.ConfigRetroPlus;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.Biomes;
import net.minecraftforge.common.BiomeDictionary;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

// New Biome Selector, works on a more sophisticated data set
public class BetaPlusBiomeSelectorNew extends AbstractBiomeSelector
{
	// FIELDS //
	private static ArrayList<Biome> frozenBiomes; // Biomes below Frozen Threshold
	private static ArrayList<Biome> frozenHillBiomes; // Frozen Hilly Biomes
	private static ArrayList<Biome> coldBiomes; // Cold Biomes
	// Threshold values
	private static final double frozenThreshold = 0.1; // PLACEHOLDER
	private static final double coldThreshold = ConfigRetroPlus.coldTh;
	private static final double warmThreshold = 0.75; // PLACEHOLDER
	private static final double hotThreshold = 0.97; // PLACEHOLDER

	private static final double dryThreshold = 0.25; // PLACEHOLDER
	private static final double wetThreshold = 0.75; // PLACEHOLDER

	public BetaPlusBiomeSelectorNew()
	{
		super(Lists.newArrayList(Biomes.BEACH, Biomes.DESERT));
	}


	// METHODS //


	// selected is usually randomly generated by the Voronoi generator and passed in
	// isHilly determines which list to use
	@Override
	public Biome getBiome(double temperature, double humidity, double selected, TerrainType type)
	{
		Biome selectBiome = Biomes.BADLANDS_PLATEAU;
		// Switch between selections of biome based on the TerrainType Enum
		switch (type)
		{
			case land:
			{
				// Do some fun stuff regarding finding normal biomes
				selectBiome =  getLandBiome(temperature, humidity, selected);
				break;
			}
			case hillyLand:
			{
				// Get Hilly Biomes, which can be counterparts of normal biomes, or special types
				selectBiome = getHillBiome(temperature, humidity, selected);
				break;
			}
			case sea:
			{
				// Get typical ocean biomes.
				selectBiome = getOceanBiome(temperature, humidity, selected);
				break;
			}
			case deepSea:
			{
				// Get deeper ocean biomes based on temperature
				selectBiome = Biomes.DEEP_LUKEWARM_OCEAN; // TODO
				break;
			}
			case island:
			{
				// Islands are strange, and will most likely be selected entirely at random
				selectBiome = getIslandBiome(selected);
				break;
			}
			case generic:
			{
				// This is an issue.
				selectBiome = Biomes.DEFAULT;
				break;
			}
		}
		return selectBiome;
	}

	// New Implementation! Should allow for a more comprehensive and easier to configure system.
	// TODO: DEPRECATE SELECTED VARIABLE!
	public static Biome selectBiome(double temperature, double humdity, double selected, TerrainType type)
	{
		// Get the list of candidate Biomes from the temperature & humidity.

		// Potentially useful Values
		// Biome.getDefaultTemperature() returns the temperature value
		// Biome.getDownfall() returns the humidity value
		// Biome.getTempCategory() returns the enumerated Temp category
		// Biome.getPrecipitation() returns the enumerated Rain (Dry, Rain, Snow)
		// BiomeDictionary.getTypes() looks to return a "Type" which is forge.
		// BiomeDictionary.getBiomes() returns all Biomes of a specific type
		// Explore BiomeDictionary types instead? NO, they dont encompass the deep ocean area.
		// Instead, map BiomeDictionary values.

		// The list of Biomes must be referenced.
		// It does not look like there is a list of Hilly Biomes, so I will have to make my own list.
		// Possibly a Pair of two Biomes with normal and hilly would be a good idea? How will I handle biomes like plains then?

		Biome selectBiome;
		Set<Biome> biomeSet;
		int selIdx;

		// HOT, COLD are Defined for almost all biomes.


		if (type == TerrainType.hillyLand)
		{
			// Have to determine type.
			// Maybe a method with signature: TEMP, HUMIDITY, SELECTED, LIST<BIOME> would be useful?
			// It would take the list of all the Biomes with the type, and pick the ones close enough, make a new list, then pick one.
			biomeSet = BiomeDictionary.getBiomes(BiomeDictionary.Type.HILLS);
			selIdx = (int) (selected * biomeSet.size());
			selectBiome = Lists.newArrayList(biomeSet).get(selIdx);
		}
		else if (type == TerrainType.land)
		{
			selectBiome = Biomes.PLAINS;
		}
		else if (type == TerrainType.sea)
		{
			selectBiome = Biomes.OCEAN;
		}
		else if (type == TerrainType.deepSea)
		{
			selectBiome = Biomes.DEEP_OCEAN;
		}
		else if (type == TerrainType.island)
		{
			selIdx = (int) (selected * ConfigRetroPlus.islandBiomeList.size());
			selectBiome = ConfigRetroPlus.islandBiomeList.get(selIdx);
			BetaPlus.LOGGER.info("ISLAND");
		}
		else
		{
			selectBiome = Biomes.SAVANNA;
		}

		return selectBiome;
	}


	// Gets an Island Biome from the registered list.
	// Primarily, this gives Mushroom islands / Regular Biomes in vanilla
	public static Biome getIslandBiome(double selected)
	{
		// Multiply by length
		int selectIdx = (int) (selected * ConfigRetroPlus.islandBiomeList.size());
		return ConfigRetroPlus.islandBiomeList.get(selectIdx);
	}

	// HELPER METHODS //
	// These will look largely the same, and serve only to make my life simpler.

	// Gets a "Land" Type Biome
	private static Biome getLandBiome(double temperature, double humidity, double selected)
	{
		int selectIdx = 0;
		// If Frozen
		if (temperature < frozenThreshold)
		{
			selectIdx = (int) (selected * ConfigRetroPlus.frozenBiomesList.size());
			return ConfigRetroPlus.frozenBiomesList.get(selectIdx);
		}
		// If Extremely Hot
		else if (temperature > hotThreshold)
		{
			return Biomes.DESERT; // PLACEHOLDER
		}
		// Cold
		else if (temperature < coldThreshold)
		{
			// Dry, like a tundra
			if (humidity < dryThreshold)
			{
				selectIdx = 1; // PLACEHOLDER
				return Biomes.SNOWY_TUNDRA;
			}
			// Wet, like a swamp.
			else if (humidity > wetThreshold)
			{
				return Biomes.DARK_FOREST;
			}
			// Temperate, like a forest.
			else
			{
				return Biomes.TAIGA;
			}
		}
		// Warm
		else if (temperature > warmThreshold)
		{
			// Dry, like a tundra
			if (humidity < dryThreshold)
			{
				selectIdx = 1; // PLACEHOLDER
				return Biomes.SAVANNA;
			}
			// Wet, like a swamp.
			else if (humidity > wetThreshold)
			{
				return Biomes.JUNGLE;
			}
			// Temperate, like a forest.
			else
			{
				return Biomes.FOREST;
			}
		}
		// Temperate Biomes are selected last
		else
		{
			// Dry, like a tundra
			if (humidity < dryThreshold)
			{
				selectIdx = 1; // PLACEHOLDER
				return Biomes.SUNFLOWER_PLAINS;
			}
			// Wet, like a swamp.
			else if (humidity > wetThreshold)
			{
				return Biomes.FLOWER_FOREST;
			}
			// Temperate, like a forest.
			else
			{
				return Biomes.PLAINS;
			}
		}
	}

	private static Biome getHillBiome(double temperature, double humidity, double selected)
	{
		int selectIdx = 0;
		// If Frozen
		if (temperature < frozenThreshold)
		{
			selectIdx = (int) (selected * ConfigRetroPlus.frozenHillBiomesList.size());
			return ConfigRetroPlus.frozenHillBiomesList.get(selectIdx);
		}
		// If Extremely Hot
		else if (temperature > hotThreshold)
		{
			return Biomes.DESERT_HILLS; // PLACEHOLDER
		}
		// Cold
		else if (temperature < coldThreshold)
		{
			// Dry, like a tundra
			if (humidity < dryThreshold)
			{
				selectIdx = 1; // PLACEHOLDER
				return Biomes.SNOWY_MOUNTAINS;
			}
			// Wet, like a swamp.
			else if (humidity > wetThreshold)
			{
				return Biomes.DARK_FOREST_HILLS;
			}
			// Temperate, like a forest.
			else
			{
				return Biomes.TAIGA_HILLS;
			}
		}
		// Warm
		else if (temperature > warmThreshold)
		{
			// Dry, like a tundra
			if (humidity < dryThreshold)
			{
				selectIdx = 1; // PLACEHOLDER
				return Biomes.SAVANNA_PLATEAU;
			}
			// Wet, like a swamp.
			else if (humidity > wetThreshold)
			{
				return Biomes.BAMBOO_JUNGLE_HILLS;
			}
			// Temperate, like a forest.
			else
			{
				return Biomes.BIRCH_FOREST_HILLS;
			}
		}
		// Temperate Biomes are selected last
		else
		{
			// Dry, like a tundra
			if (humidity < dryThreshold)
			{
				selectIdx = 1; // PLACEHOLDER
				return Biomes.GRAVELLY_MOUNTAINS;
			}
			// Wet, like a swamp.
			else if (humidity > wetThreshold)
			{
				return Biomes.WOODED_MOUNTAINS;
			}
			// Temperate, like a forest.
			else
			{
				return Biomes.MOUNTAINS;
			}
		}
	}

	private static Biome getOceanBiome(double temperature, double humidity, double selected)
	{
		if (temperature < frozenThreshold)
		{
			return Biomes.FROZEN_OCEAN;
		}
		else if (temperature > hotThreshold)
		{
			return Biomes.WARM_OCEAN;
		}
		else
		{
			return Biomes.OCEAN;
		}
	}


}
